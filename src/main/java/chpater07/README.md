# CHAPTER 07. 객체 분해

> 문제를 해결하기 위해 사용하는 저장소는 장기 기억이 아닌 단기 기억이다. 문제를 해결하기 위해서는 필요한 정보들을 먼저 단기 기억 안으로 불러들여야 한다. 그러나 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격하게 떨어지고 만다. 
>
> 이런 현상을 인지 과부화(cognitive overload)라고 부른다.

인지 과부하를 방지하는 가장 좋은 방법은 단기 기억 안에 보관할 정보의 양을 조절하는 것이다.

본질적인 정보만 남기고 불필요한 세부 사항을 걸러내면 문제를 단순화 할 수 있다.

이처럼 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업을 `추상화`라고 부른다.

가장 일반적인 추상화 방법은 한 번에 다뤄야 하는 문제의 크기를 줄이는 것이다.

큰 문제를 해결 가능한 작은 문제로 나누는 작업을 `분해(decomposition)`라고 부른다.

- 분해의 목적
  - 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한 번에 처리할 수 있는 규모의 문제로 나누는 것
  - 정보의 가장 작은 단위로서의 개별 항목이 아니라 하나의 단위로 취급될 수 있는 `논리적인 청크`를 의미한다.
    - 예를 들면, 11자리 정수 8개를 한꺼번에 기억하는 것은 힘들지만, 11자리 정수를 전화번호라는 개념적 청크로 묶으면 8명에 대한 전화번호를 기억할 수 있도록 인지능력을 향상 시킬 수 있다.

추상화를 더 큰 규모의 추상화로 압축 -> 단기 기억의 한계를 초월 할 수 있다.

> 추상화와 분해는 인간이 세계를 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구라고 할 수 있다.



## 01. 프로시저 추상화와 데이터 추상화

- 어셈블리어 : 기계어에 인간이 이해할 수 있는 상징을 부여한 노력의 결과
- 고수준 언어: 인간의 눈높이에 맞는 기계 독립적이고 의미 있는 추상화를 제공하려는 시도의 결과

프로그래밍 언어를 통해 표현되는 추상화의 발전은 다양한 프로그래밍 패러다임의 탄생으로 이어졌다.

> 프로그래밍 패러다임은 프로그래밍을 구성하기 위해 사용하는 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해하는 방법의 두 가지 요소로 결정된다. 

따라서, 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.

현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 메터니즘은 `프로시저 추상화(procedure abstraction)`와 `데이터 추상화(data abstraction)`이다.

- 프로시저 추상화 : 소프트웨어가 무엇을 해야하는지 추상화
- 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지 추상화

프로그래밍 패러다임 = 적절한 추상화의 윤곽을 따라 시스템을 어떤 식으로 나눌 것인지를 결정하는 원칙과 방법의 집합

-> 프로그래밍 패러다임들은 프로시저 추상화나 데이터 추상화 중심으로 시스템의 분해 방법을 설명한다.

> 시스템을 분해하는 방법을 결정하려면 프로시저 추상화 중심/데이터 추상화 중심으로 할 것인지 결정해야한다.

- 프로시저 추상화 중심

  - 기능 분해 = 알고리즘 분해

- 데이터 추상화 중심

  - 타입 추상화(=추상 데이터 타입)

  - 데이터 중심으로 프로시저 추상화(=객체지향)

    > `역할과 책임을 수행하는 객체`가 객체지향 패러다임이 이용하는 추상화
    >
    > 기능을 `협력하는 공동체`를 구성하도록 객체들로 나누는 과정이 객체지향 패러다임에서의 `분해`를 의미한다.

#### 프로그래밍 언어의 관점에서의 객체 지향

프로그래밍 언어의 관점에서 객체지향이란 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 방법이다.

객체를 구현하기 위해 대부분의 객체지향언어는 `클래스`라는 도구를 제공한다.

> 프로그래밍 언어의 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것이다.



### 정리하자면

복잡성을 극복하는 방법  = 효과적인 추상화 메커니즘과 분해 방법을 찾는 것



### 의문점

- 객체지향이 전통적인 기능 분해 방법에 비해 효과적인 이유는?
- 효과적이라는 말의 의미는?

해답을 찾기 위해 전통적인 기능 분해 방법에서 시작해 객체지향 분해 방법에 이르는 좌절과 극복의 역사를 살펴보자



## 02. 프로시저 추상화와 기능 분해

### 메인 함수로서의 시스템

기능을 시스템을 분해하기 위한 기준으로 사용 -> 알고리즘 분해/기능 분해

기능 분해의 관점에서 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해한다.

- `프로시저`는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법 (=수학의 함수 개념)
- 프로시저를 추상화라고 부르는 이유 : 내부 상세 구현 내용 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문
- 프로시저는 잠재적으로 `정보은닉(information hiding)`의 가능성을 제시하지만, 효과적인 정보은닉 체계를 구축하는데 한계가 있다.

> 기본적으로 기능 분해는 책의 목자를 정리하고 그 안에 내용을 채워 넣는 것과 유사하다.

전통적인 기능 분해 방법 : `하향식 접근법(Top-Down Approach)`

- 가장 최상위 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다.
- 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때 까지 계속된다.

### 예제 : 급여 관리 시스템

급여 관리 시스템을 구현하기 위해 `기능 분해 방법`을 이용

하향식 접근법에 따르면 

- 최상위의 추상적인 함수 정의는 시스템 기능을 표현하는 하나의 문장으로 나타내고

- 이 문장을 구성하는 좀 더 세부적인 단계의 문장으로 분해해 나가는 방식을 따른다.

- 모든 문장이 정제 과정을 거치면서 하나 이상의 좀 더 단순하고 구체적인 문장들의 조합으로 분해돼야 한다

하향식 기능 분해는

- 논리적이고 체계적인 시스템 개발 절차를 제시한다.

기능 분해 방법에서는 기능을 중심으로 필요한 데이터를 결정한다.

- 데이터는 기능을 보조하는 조연의 역할에 머무른다.

이것은 유지보수에 다양한 문제를 야기한다.



### 하향식 기능 분해의 문제점

> 하향식 기능 분해 방식이 가지는 문제점을 이해하는 것 = 유지보수 관점에서 객체지향의 장점을 이해할 수 있는 좋은 출발점

`설계는 코드 배치 방벙이며 설계가 필요한 이유는 변경에 대비하기 위한것이라는 점을 기억하자`

#### 1. 시스템은 하나의 메인 함수로 구성돼 있지 않다.

하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합하다.

하지만 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않다. 

-> 현대적인 시스템은 동등한 수준의 다양한 기능으로 구성되기 때문에

> 실제 시스템에는 정상(Top)이란 존재하지 않는다.  [Meyer00]



#### 2. 기능 추가나 요구사항 변경으로 인해 메인함수를 빈번하게 수정해야 한다.

​	하향식 기능 분해의 경우 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다.

​	기존 코드를 수정하는 것은 항상 새로운 버그를 만드어낼 확률을 높인다.



#### 3. 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.

​	하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입출력을 함께 고민하도록 강요한다.

​	결과적으로 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.

​	비즈니스 로직과 사용자 인터페이스가 변경되는 빈도가 다른데, 사용자 인터페이스 변경하는 경우에 비즈니스 로직까지 변경에 영향을 받게 된다.

 	-> 변경에 불안정한 아키텍처를 낳는다. 



#### 4. 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.

​	하향식 기능 분해 방법은 설계를 시작하는 시점부터 `무엇`을 해야하는지가 아니라 `어떻게` 동작해야하하는지 집중하도록 만든다.

​	하향식 접근법의 설계는 처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 실행 순서를 정의하는 시간 제약을 강조한다. -> 기능 분해 방식은 중앙집중 제어 스타일의 형태를 띨 수 밖에 없다.

​	문제는 중요한 설계 결정사항인 함수의 제어 구조가 빈번한 변경의 대상이라는 점이다. 기능 추가되거나 변경될 때마다 초기에 결정된 함수들의 제어 구조가 올바르지 않다는 것이 판명된다.

​	해결 방법 : 시간적인 제약에 대한 미련을 버리고 좀 더 안정적인 논리적 제약을 설계의 기준으로 삼는 것

​	-> 객체지향은 객체 사이의 논리적인 관계를 중심으로 설계를 이끌어 나간다. -> 여러 객체 사이로 제어 주체가 분산된다.

##### 재사용 관련

​	함수가 재사용 가능하려면 상위 함수보다 더 일반적이어야 한다.

​	하지만 하향식 접근법에서 하위 함수는 항상 상위 함수보다 문맥에 더 종속적이다. -> 재사용성과 반대되는 개념

​	`하향식 설계와 관련된 모든 문제의 원인은 결합도이다.`

​	함수는 상위 함수가 강요하는 문맥에 강하게 결합된다. -> 강한 결합도는 시스템을 변경에 취약하게 만든다.

-> 작은 변경만으로도 전체 시스템을 위험하게 만든다.



#### 5. 데이터 형식이 변결될 경우 파급효과를 예측할 수 없다.

하향식 기능 분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다는 것이다.

데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는 것이 생각보다 쉽지 않다.

데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다.

즉, 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 한다.

이것이 의존성 관리의 핵심이다. 

> 변경에 대한 영향을 최소화하기 위해 영향을 받는 부분과 받지 않는 부분을 명확히 하고 잘 정의된 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제하는 것



### 언제 하향식 분해가 유용한가?

- 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임으로 남아 있다.
- 프로그래밍 과정에서 이미 해결된 알고리즘을 문서화하고 서술하는 데는 훌륭한 기법이다.



## 03. 모듈

### 정보은닉과 모듈

시스템 변경을 관리하는 전략 

- 기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해하는 것
- 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제하는 것

> 정보은닉은 시스템을 모듈 단위로 분해하기 위한 기본원리로 
>
> 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야한다는 것이 핵심이다.

정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리이다.

모듈은 변경 가능성이 있는 비밀은 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 한다.

모듈은 다음과 같은 두 가지 비밀을 감춰야한다.

1. 복잡성
2. 변경 가능성

비밀이 반드시 데이터일 필요는 없다. 복잡한 로직이나 변경 가능성이 큰 자료 구조일 수도 있다.

### 모듈의 장점

1. 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
2. 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
3. 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.

모듈 내부는 높은 응집도를 유지하고 퍼블릭 인터페이스를 통해서 통신하기 때문에 낮은 결합도를 유지한다.

`정보 은닉이라는 개념을 통해 데이터라는 존재를 설계의 중심 요소로 부가시켰다 -> 모듈에 있어서 핵심은 데이터다.`

기능이 아니라 데이터를 중심으로 시스템을 분해하는 것 -> 모듈은 데이터와 함수가 통합된 한 차원 높은 추상화를 제공하는 설계 단위이다.

### 모듈의 단점

- 인스턴스의 개념을 제공하지 않는다.

  -> 추상 데이터 타입 개념이 등장한 이유



## 04. 데이터 추상화와 추상 데이터 타입





